
//% color=#0000BF icon="\uf108" block="OLED 16x8" weight=20
//% groups='["beim Start"]'
namespace oledssd1315
/* 230908 231011 https://github.com/calliope-net/oled-16x8

Grove - OLED Yellow&Blue Display 0.96(SSD1315)
https://wiki.seeedstudio.com/Grove-OLED-Yellow&Blue-Display-0.96-SSD1315_V1.0/

SparkFun Qwiic EEPROM Breakout - 512Kbit
https://www.sparkfun.com/products/18355

initdisplaycodes from https://gist.githubusercontent.com/pulsar256/564fda3b9e8fc6b06b89/raw/4bb559d4088e42f7b4859a8533be920434818617/ssd1306_init.c

https://cdn-shop.adafruit.com/datasheets/UG-2864HSWEG01.pdf (Seite 15, 20 im pdf)

OLED Display mit EEPROM neu programmiert von Lutz Elßner im September 2023
*/ {
    //% group="beim Start"
    //% block="i2c %pADDR beim Start || i2c-Check %ck"
    //% ck.shadow="toggleOnOff" ck.defl=1
    //% blockSetVariable=OLED16x8
    export function beimStart(pADDR: eADDR, ck?: boolean): oledclass {
        return new oledclass(pADDR, (ck ? true : false)) // optionaler boolean Parameter kann undefined sein
    }


    export class oledclass {
        private readonly i2cADDR: eADDR
        private readonly i2cCheck: boolean // i2c-Check
        private i2cError: number = 0 // Fehlercode vom letzten WriteBuffer (0 ist kein Fehler)
        
        constructor(pADDR: eADDR, ck: boolean) {
            this.i2cADDR = pADDR
            this.i2cCheck = ck
            this.i2cError = 0 // Reset Fehlercode
            //this.i2cRESET_OUTPUTS()
        }

        //% group="OLED Display 0.96 + SparkFun Qwiic EEPROM Breakout - 512Kbit"
        //% block="i2c %pADDR beim Start || invert %pInvert drehen %pFlip i2c-Check %ck EEPROM: Zeichensatz %pEEPROM_Startadresse i2c %pADDR_EEPROM" weight=8
        //% pADDR.shadow="oledssd1315_eADDR"
        //% pInvert.shadow="toggleOnOff" pInvert.defl=false
        //% pFlip.shadow="toggleOnOff" pFlip.defl=false
        //% ck.shadow="toggleOnOff" ck.defl=1
        //% pEEPROM_Startadresse.shadow="oledssd1315_eEEPROM_Startadresse"
        //% pADDR_EEPROM.shadow="oledssd1315_eADDR_EEPROM"
        //% inlineInputMode=inline
        init(pADDR: number, pInvert?: boolean, pFlip?: boolean, ck?: boolean,
            pEEPROM_Startadresse?: number, pADDR_EEPROM?: number): void {

            //if (!between(pADDR, eADDR.OLED_16x8_x3C, eADDR.OLED_16x8_x3D)) {
            //    basic.showString("nur x3C oder x3D ist gültig")
            //} else {
            // nur diese beiden i2c-Adressen sind gültig
            /* 
                    n_i2cCheck = (ck ? true : false) // optionaler boolean Parameter kann undefined sein
                    n_i2cError_x50 = 0 // Reset Fehlercode
            
                    // i2c Adresse vom EEPROM nur speichern, wenn Parameter angegeben (nicht NaN)
                    if (between(pADDR_EEPROM, 0x50, 0x57)) { n_ADDR_EEPROM = pADDR_EEPROM }
            
                    // Startadresse Zeichensatz im EEPROM je Display getrennt speichern, wenn angegeben
                    if (between(pEEPROM_Startadresse, 0x0000, 0xFFFF)) {
                        if (pADDR == eADDR.OLED_16x8_x3C) {
                            n_i2cError_x3C = 0
                            n_0x3C_EEPROM_Startadresse = pEEPROM_Startadresse
                        }
                        else if (pADDR == eADDR.OLED_16x8_x3D) {
                            n_i2cError_x3D = 0
                            n_0x3D_EEPROM_Startadresse = pEEPROM_Startadresse
                        }
                    } */

            // Vcc Generated by Internal DC/DC Circuit
            const vccext = false

            let bu = Buffer.create(23)   // muss Anzahl der folgenden setUint8 entsprechen
            let offset = 0               // Buffer offset (offset++ liest erst den Wert und erhöht ihn dann)

            bu.setUint8(offset++, eCONTROL.x00_xCom) // CONTROL Byte 0x00: folgende Bytes (im selben Buffer) sind alle command und kein CONTROL
            // CONTROL Byte 0x80: ignoriert 2. command-Byte (0xD5) und wertet es als CONTROL
            // CONTROL Byte 0x80: nach jedem command muss (im selben Buffer) wieder ein CONTROL 0x80 vor dem nächsten command kommen
            // CONTROL Byte 0x80: wenn ein CONTROL 0x40 folgt, können (im selben Buffer) auch Display-Daten GDDRAM folgen


            // https://cdn-shop.adafruit.com/datasheets/UG-2864HSWEG01.pdf (Seite 15, 20 im pdf)

            bu.setUint8(offset++, 0xAE)  // Set display OFF

            bu.setUint8(offset++, 0xD5)  // Set Display Clock Divide Ratio / OSC Frequency
            bu.setUint8(offset++, 0x80)  //     default 0x80

            bu.setUint8(offset++, 0xA8)  // Set Multiplex Ratio
            bu.setUint8(offset++, 0x3F)  //     Multiplex Ratio for 128x64 (64-1)

            bu.setUint8(offset++, 0xD3)  // Set Display Offset
            bu.setUint8(offset++, 0x00)  //     Display Offset

            bu.setUint8(offset++, 0x40)  // Set Display Start Line

            bu.setUint8(offset++, 0x8D)  // Set Charge Pump
            //bu.setUint8(offset++, 0x14)  //     Charge Pump (0x10 Disable; 0x14 7,5V; 0x94 8,5V; 0x95 9,0V)
            bu.setUint8(offset++, (vccext ? 0x10 : 0x14))

            //bu.setUint8(offset++, 0xA1)  // Set Segment Re-Map default 0xA0
            bu.setUint8(offset++, (!pFlip ? 0xA1 : 0xA0))

            //bu.setUint8(offset++, 0xC8)  // Set Com Output Scan Direction default 0xC0
            bu.setUint8(offset++, (!pFlip ? 0xC8 : 0xC0))

            bu.setUint8(offset++, 0xDA)  // Set COM Hardware Configuration
            bu.setUint8(offset++, 0x12)  //     COM Hardware Configuration

            bu.setUint8(offset++, 0x81)  // Set Contrast (Helligkeit)
            //bu.setUint8(offset++, 0xCF)  //     Contrast default 0x7F
            bu.setUint8(offset++, (vccext ? 0x9F : 0xCF))

            bu.setUint8(offset++, 0xD9)  // Set Pre-Charge Period
            //bu.setUint8(offset++, 0xF1)  //     Pre-Charge Period (0x22 External, 0xF1 Internal)
            bu.setUint8(offset++, (vccext ? 0x22 : 0xF1))

            bu.setUint8(offset++, 0xDB)  // Set VCOMH Deselect Level
            bu.setUint8(offset++, 0x40)  //     VCOMH Deselect Level default 0x20

            bu.setUint8(offset++, 0xA4)  // Set all pixels OFF

            bu.setUint8(offset++, (pInvert ? 0xA7 : 0xA6))  // Set display not inverted / A6 Normal A7 Inverse display

            //bu.setUint8(offset++, 0xAF)  // Set display ON

            this.i2cWriteBuffer(bu) // nur 1 Buffer wird gesendet


            bu = Buffer.create(135)
            offset = 0            //offset = setCursorBuffer6(bu, 0, 0, 0)

            bu.setUint8(offset++, eCONTROL.x80_1Com) // CONTROL+1Command
            bu.setUint8(offset++, 0xB0)// | (page & 0x07)) // page number

            bu.setUint8(offset++, eCONTROL.x80_1Com) // CONTROL+1Command
            bu.setUint8(offset++, 0x00)// | (col & 0x0F)) // lower start column address 0x00-0x0F 4 Bit

            bu.setUint8(offset++, eCONTROL.x80_1Com) // CONTROL+1Command
            bu.setUint8(offset++, 0x10)// | (col >> 4) & 0x07) // upper start column address 0x10-0x17 3 Bit

            bu.setUint8(offset++, eCONTROL.x40_Data) // CONTROL+DisplayData
            bu.fill(0x00, offset++, 128)

            for (let page = 0; page <= 7; page++) {
                bu.setUint8(1, 0xB0 | page) // an offset=1 steht die page number (Zeile 0-7)
                // sendet den selben Buffer 8 Mal mit Änderung an 1 Byte
                // true gibt den i2c Bus dazwischen nicht für andere Geräte frei
                this.i2cWriteBuffer(bu, true) // Clear Screen
            }


        }

        private i2cWriteBuffer(buf: Buffer, repeat: boolean = false) { // repeat funktioniert nicht
            if (this.i2cError == 0) { // vorher kein Fehler
                this.i2cError = pins.i2cWriteBuffer(this.i2cADDR, buf, repeat)
                if (this.i2cCheck && this.i2cError != 0)  // vorher kein Fehler, wenn (n_i2cCheck=true): beim 1. Fehler anzeigen
                    basic.showString(Buffer.fromArray([this.i2cADDR]).toHex()) // zeige fehlerhafte i2c-Adresse als HEX
            } else if (!this.i2cCheck)  // vorher Fehler, aber ignorieren (n_i2cCheck=false): i2c weiter versuchen
                this.i2cError = pins.i2cWriteBuffer(this.i2cADDR, buf, repeat)
            //else { } // n_i2cCheck=true und n_i2cError != 0: weitere i2c Aufrufe blockieren
        }
    }
    enum eCONTROL { // Co Continuation bit(7); D/C# Data/Command Selection bit(6); following by six "0"s
        // CONTROL ist immer das 1. Byte im Buffer
        x00_xCom = 0x00, // im selben Buffer folgen nur Command Bytes ohne CONTROL dazwischen
        x80_1Com = 0x80, // im selben Buffer nach jedem Command ein neues CONTROL [0x00 | 0x80 | 0x40]
        x40_Data = 0x40  // im selben Buffer folgen nur Display-Data Bytes ohne CONTROL dazwischen
    }
}